import java.time.Instant

plugins {
    id 'java'
    id 'application'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'com.gorylenko.gradle-git-properties' version '2.4.2'
}

group = project.findProperty("group") ?: "com.ursineenterprises"
version = project.findProperty("version") ?: "1.0.0-SNAPSHOT"
description = project.findProperty("description") ?: "A tool to generate Google Calendar events from a CSV file."

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(23)
    }
}

application {
    mainClass.set(project.property("mainClass"))
}

repositories {
    mavenCentral()
    google()
}

test {
    useJUnitPlatform()
}

dependencies {
    compileOnly 'org.projectlombok:lombok:1.18.36'
    annotationProcessor 'org.projectlombok:lombok:1.18.36'

    testCompileOnly 'org.projectlombok:lombok:1.18.36'
    testImplementation 'org.mockito:mockito-core:5.14.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.14.0' // if using JUnit 5
    testImplementation 'org.junit.jupiter:junit-jupiter:5.11.3'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.36'

    implementation 'com.google.apis:google-api-services-calendar:v3-rev20250404-2.0.0'
    implementation 'com.google.auth:google-auth-library-oauth2-http:1.22.0'
    implementation 'com.google.api-client:google-api-client:2.4.0'
    implementation 'com.google.api-client:google-api-client-gson:2.0.1'
    implementation 'com.google.oauth-client:google-oauth-client-jetty:1.39.0'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'
    implementation 'com.fasterxml.jackson.core:jackson-core:2.17.2'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.17.2'

    implementation 'org.slf4j:slf4j-simple:2.0.12'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}

tasks.withType(JavaCompile) {
    options.annotationProcessorPath = configurations.annotationProcessor
}

tasks.test {
    useJUnitPlatform()
}

def buildTime = Instant.now().toString()
def gitCommit = 'UNKNOWN'
try {
    def proc = ["git", "rev-parse", "--short", "HEAD"].execute(null, rootDir)
    proc.waitFor()
    gitCommit = proc.in.text.trim()
} catch (Exception e) {
    println "Could not determine git commit: ${e.message}"
}

shadowJar {
    archiveBaseName.set(project.property("archiveBaseName"))
    archiveClassifier.set("")
    archiveVersion.set(version.toString())

    mergeServiceFiles()

    manifest {
        attributes(
                "Implementation-Version": version.toString(),
                "Build-Time": buildTime,
                "Git-Commit": gitCommit
        )
    }

    // Set Main-Class after manifest to avoid line wrapping
    doLast {
        def jarFile = archiveFile.get().asFile
        def mainClassName = project.property("mainClass")
        ant.jar(update: true, destfile: jarFile) {
            delegate.manifest {
                attribute(name: 'Main-Class', value: mainClassName)
            }
        }
    }
}

tasks.named('distZip') {
    dependsOn tasks.named('shadowJar')
}

tasks.named('distTar') {
    dependsOn tasks.named('shadowJar')
}

tasks.named('startScripts') {
    dependsOn tasks.named('shadowJar')
}

tasks.named('startShadowScripts') {
    dependsOn tasks.named('jar')
}

tasks.register('pkg') {
    group = 'build'
    description = 'Cleans, builds, and produces the shadow/fat JAR'
    doFirst {
        if (project.hasProperty('forceClean') && project.property('forceClean') == 'true') {
            tasks.clean.execute()
        }
    }
    dependsOn 'clean', 'build', 'shadowJar'
}

tasks.register("release") {
    group = "versioning"
    description = "Converts SNAPSHOT version to release version and builds fat JAR"

    dependsOn "shadowJar"

    doLast {
        def currentVersion = project.version.toString()
        if (!currentVersion.endsWith("-SNAPSHOT")) {
            println "Already a release: $currentVersion"
            return
        }

        def releaseVersion = currentVersion.replace("-SNAPSHOT", "")
        println "Releasing version $releaseVersion"

        // Update gradle.properties
        def propertiesFile = file("gradle.properties")
        def props = new Properties()
        propertiesFile.withInputStream { props.load(it) }
        props.setProperty("version", releaseVersion)
        propertiesFile.withOutputStream { props.store(it, null) }

        project.version = releaseVersion

        println "Production JAR built: build/libs/${project.name}-$releaseVersion.jar"
    }
}

tasks.register("nextSnapshot") {
    group = "versioning"
    description = "Bumps version (major, minor, patch) and appends -SNAPSHOT"

    // Accept a project property "type", default to "patch"
    def bumpType = project.hasProperty("type") ? project.property("type") : "patch"

    doLast {
        def currentVersion = project.version.toString()
        def releaseVersion = currentVersion.endsWith("-SNAPSHOT") ? currentVersion.replace("-SNAPSHOT", "") : currentVersion
        def parts = releaseVersion.tokenize('.')
        if (parts.size() != 3) {
            throw new GradleException("Version must be in x.y.z format")
        }

        def major = parts[0].toInteger()
        def minor = parts[1].toInteger()
        def patch = parts[2].toInteger()

        switch (bumpType) {
            case "major":
                major += 1
                minor = 0
                patch = 0
                break
            case "minor":
                minor += 1
                patch = 0
                break
            case "patch":
                patch += 1
                break
            default:
                throw new GradleException("Invalid type: $bumpType. Must be major, minor, or patch")
        }

        def nextSnapshot = "$major.$minor.$patch-SNAPSHOT"

        // Update gradle.properties
        def propertiesFile = file("gradle.properties")
        def props = new Properties()
        propertiesFile.withInputStream { props.load(it) }
        props.setProperty("version", nextSnapshot)
        propertiesFile.withOutputStream { props.store(it, null) }

        project.version = nextSnapshot
        println "Next development version set to $nextSnapshot"
    }
}
